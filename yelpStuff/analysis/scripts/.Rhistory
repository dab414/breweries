ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme(panel.background = element_rect(fill = 'white', color = 'black'))
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
theme_bw()
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme(strip.background = element_rect(fill = 'white', color = 'black')) +
theme_bw()
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme_bw() +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
library(knitr)
library(tidyverse)
library(data.table)
library(chron)
library(imputeMissings)
library(fastDummies)
library(stringr)
yelp <- read.csv('../data/yelpData.csv', stringsAsFactors = FALSE)
colnames(yelp) <- tolower(colnames(yelp))
## drop breweries that couldn't be scraped
yelp <-yelp[!is.na(yelp$ratings),]
yelp
yelp %>%
group_by(name) %>%
summarize(n()) %>%
nrow()
print(typeof(yelp$mon))
print(class(yelp$mon))
s1 <- yelp$mon[1]
s2 <- yelp$tue[1]
print(c(s1,s2))
## Regex to extract time
simpleTime <- '\\d+:\\d\\d\\s\\w\\w'
## keep one row per brewery
test <- yelp[match(unique(yelp$name), yelp$name),]
## Regex and time conversion to get time data to behave like time data
test <- test %>%
select(name, mon, tue, wed, thu, fri, sat, sun) %>%
gather(day, times, mon:sun) %>%
## Separate into open and close times based on the '-'
separate(times, into=c('open', 'close'), sep='-') %>%
## match only strings matching time format
mutate(open = str_extract(open, simpleTime),
close = str_extract(close, simpleTime))# %>%
## Convert to time
test$open <- strptime(test$open, format = '%I:%M %p')
test$close <- strptime(test$close, format = '%I:%M %p')
## Strip out the date, keep only the time
test$open <- times(sub('.*\\s+', '', test$open))
test$close <- times(sub('.*\\s+', '', test$close))
## Doing some serious data reshaping to get time information on one line per brewery
## Goal is to spread time open, time closed, and total time to wide vars of the form: day_open/close_TotalTime/Not
yelp <- x <- test %>%
## Compute total hours open
mutate(totalHours = abs(test$close - test$open)) %>%
## Gather open / close times
gather(timePeriod, time, open:close) %>%
## Gather total hours and open / close times
gather(TotalOrTime, value, totalHours, time) %>%
## Combine day, open / close times, total time
unite(variable, day, timePeriod, TotalOrTime) %>%
## Spread across the united variable
spread(variable, value) %>%
inner_join(yelp)
## open and close for total hours are the same thing
sum(yelp$thu_open_totalHours == yelp$thu_close_totalHours, na.rm = TRUE) == nrow(yelp[!is.na(yelp$thu_open_totalHours),])
yelp <- yelp %>%
select(-contains('_close_totalhours'))
yelp
print(summary(factor(yelp$price_range)))
cleanPriceRange <- function(price_range){
### takes as input char vector price_range
### returns price range (still as a char var) sorted into three groups
cheapBucket <- c('under $10', 'inexpensive')
moderateBucket <- c('$11-30', 'A$16-35', 'Moderate')
expensiveBucket <- c('$31-60')
price_range <- tolower(price_range)
## regrettably (bc we need vectorized operations) there's no great way around the disgusting ifelse() chain
out <- ifelse(price_range %in% cheapBucket, 'cheap',
ifelse(price_range %in% moderateBucket, 'moderate',
ifelse(price_range %in% expensiveBucket, 'expensive', NA)))
return(out)
}
yelp <- yelp %>%
mutate(price_range_messy = price_range) %>%
select(-price_range) %>%
mutate(price_range = cleanPriceRange(price_range_messy))
print(summary(factor(yelp$price_range)))
yelp[500:550,]
yelp <- yelp %>%
select(-price_range_messy)
summary(factor(yelp$moreinfovar))
## Some breweries have redundant entries for moreinfovar (80 total), need to drop these for spread to work
badBrews <- yelp %>%
group_by(name) %>%
summarize(dups = sum(duplicated(moreinfovar))) %>%
filter(dups >= 1) %>%
select(name)
yelp <- yelp[!(yelp$name %in% badBrews$name),]
yelp <- yelp %>%
spread(moreinfovar, moreinfoval)
colnames(yelp) <- tolower(colnames(yelp))
yelp
summarizeNAs <- function(data) {
## Returns a sorted df where column one is the name of the original column and column two is the proportion of data missing from that column
holder <- data.frame(colName = character(), propMissing = numeric(), stringsAsFactors = FALSE)
count <- 0
for (colIndex in 1:(ncol(data))) {
count <- count+ 1
holder[count, 1] <- colnames(data)[colIndex]
holder[count, 2] <- nrow(data[is.na(data[,colIndex]),]) / nrow(data)
}
return(holder[order(holder$propMissing, decreasing = TRUE),])
}
naSummary <- summarizeNAs(yelp)
summarizeNAs(yelp)
yelp <- yelp[, !(colnames(yelp) %in% naSummary[naSummary$propMissing > .5, 1])]
colnames(yelp)
getmode <- function(v) {
v <- na.omit(v)
uniqv <- unique(v)
## tabulate takes the integer-valued vector bin and counts the number of times each integer occurs in it.
uniqv[which.max(tabulate(match(v, uniqv)))]
}
modeImputation <- function(data){
for (column in colnames(data)) {
#print(column)
modeValue <- getmode(data[,column])
data[is.na(data[,column]), column] <- modeValue #rep(modeValue, length(data[is.na(data$column), column]))
}
return(data)
}
yelp <- modeImputation(yelp)
summarizeNAs(yelp)
yelp <- yelp %>%
## If there's more than one parking option just label it 'multiple'
mutate(parking = ifelse(grepl(',', parking), 'multiple', parking))
colnames(yelp) <- gsub('-', '_', colnames(yelp))
colnames(yelp) <- tolower(gsub(' ', '_', colnames(yelp)))
dummyCols <- yelp %>%
## im gonna leave the category var alone for now
select(price_range:wheelchair_accessible)
yelp <- dummy_cols(yelp, select_columns = colnames(dummyCols), remove_first_dummy = TRUE)
colnames(yelp) <- tolower(colnames(yelp))
## Converting so dummy vars reflect yes value rather than no
yelp <- yelp %>%
mutate(accepts_credit_cards_yes = ifelse(accepts_credit_cards_no == 0, 1, 0),
bike_parking_yes = ifelse(bike_parking_no == 1, 0, 1),
wheelchair_accessible_yes = ifelse(wheelchair_accessible_no == 1, 0, 1),
accepts_apple_pay_yes = ifelse(accepts_apple_pay_no == 1, 0, 1)) %>%
select(-bike_parking_no, -accepts_credit_cards_no, -claimed_status, -accepts_apple_pay_no, -wheelchair_accessible_no, -(fri:wed))
yelp <- yelp %>%
mutate(reviews = as.numeric(str_extract(reviews, '\\d+')))#,
#my_ratings = (x1_star_count * 1 + x2_star_count * 2 + x3_star_count * 3 + x4_star_count * 4 + x5_star_count * 5) / sum(c(x1_star_count,x2_star_count,x3_star_count,x4_star_count,x5_star_count)))
## Had to resort to a for loop to calculate weighted ratings
store <- numeric()
for (row in 1:(nrow(yelp))) {
store[row] <- with(yelp[row,], (x1_star_count * 1 + x2_star_count * 2 + x3_star_count * 3 + x4_star_count * 4 + x5_star_count * 5) / sum(c(x1_star_count,x2_star_count,x3_star_count,x4_star_count,x5_star_count)))
}
yelp$my_ratings <- store
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme_bw() +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
yelp
breweries <- read.csv('../../../data/breweries.csv')
census <- read.csv('../../../data/censusData.csv')
colnames(census) <- tolower(colnames(census))
census <- census[!(census$name %in% c('United States', 'Puerto Rico Commonwealth', 'District of Columbia')),]
census <- census %>%
select(name, popestimate2017) %>%
rename(state = name, population = popestimate2017)
yelp <- breweries %>%
select(name, state) %>%
inner_join(yelp, by = 'name')
breweries <- breweries %>%
inner_join(census) %>%
select(name, state, population) %>%
group_by(state) %>%
summarize(population = max(population), nBreweries = n()) %>%
mutate(breweriesToPpl = nBreweries / population)
yelp <- yelp %>%
inner_join(breweries, by = 'state')
write.csv(yelp, '../data/cleanYelp.csv', row.names = FALSE)
library(Hmisc)
library(tidyverse)
library(data.table)
yelp <- read.csv('../data/cleanYelp.csv')
yelp
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme_bw() +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
library(Hmisc)
library(tidyverse)
library(data.table)
yelp <- read.csv('../data/cleanYelp.csv')
yelp
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme_bw() +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
## convert relevant variables to numeric for correlations
relColumns <- yelp %>%
select(contains('totalhours'), contains('time'), price_range_moderate:accepts_apple_pay_yes, my_ratings, reviews, breweriesToPpl) %>%
colnames()
relColumns
yelp[, relColumns] <- sapply(yelp[,relColumns], as.numeric)
m1 <- rcorr(as.matrix(yelp[,relColumns]))
## save out only correlations related to ratings
rs <- as.data.frame(m1$r)['my_ratings',]
ps <- as.data.frame(m1$P)['my_ratings',]
## keep significant correlations
critical_ps <- ps %>%
select(-my_ratings) %>%
gather(variable, p_value) %>%
filter(p_value < .05)
rs <- rs %>%
select(-my_ratings) %>%
gather(variable, r_value)
critical_rs <- rs[rs$variable %in% critical_ps$variable,]
critical_rs
m2 <- lm(my_ratings ~ price_range_moderate * caters_yes * parking_street * take_out_yes * accepts_credit_cards * bike_parking_yes * accepts_apple_pay * breweriesToPpl, data = yelp)
v <- summary(m2)$coefficients[,4]
n <- row.names(data.frame(summary(m2)$coefficients[,4]))
d <- data.frame(Variable = n, pValue = v, row.names = 1:(length(v)))
d[d$pValue < .05,]
yelp %>%
filter(price_range != 'expensive') %>%
group_by(price_range) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = price_range, y = ratings)) + geom_bar(stat='identity', width = .6) + geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), width = .5) + ylim(0,5) + theme_bw() +
ylab('Average Rating') + xlab('Price Range')
q()
library(tidyverse)
library(data.table)
library(Hmisc)
yelp <- read.csv('../data/cleanYelp.csv')
yelp
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme_bw() +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
## convert relevant variables to numeric for correlations
relColumns <- yelp %>%
select(contains('totalhours'), contains('time'), price_range_moderate:accepts_apple_pay_yes, my_ratings, reviews, breweriesToPpl) %>%
colnames()
relColumns
yelp[, relColumns] <- sapply(yelp[,relColumns], as.numeric)
m1 <- rcorr(as.matrix(yelp[,relColumns]))
## save out only correlations related to ratings
rs <- as.data.frame(m1$r)['my_ratings',]
ps <- as.data.frame(m1$P)['my_ratings',]
## keep significant correlations
critical_ps <- ps %>%
select(-my_ratings) %>%
gather(variable, p_value) %>%
filter(p_value < .05)
rs <- rs %>%
select(-my_ratings) %>%
gather(variable, r_value)
critical_rs <- rs[rs$variable %in% critical_ps$variable,]
critical_rs
m2 <- lm(my_ratings ~ price_range_moderate * caters_yes * parking_street * take_out_yes * accepts_credit_cards * bike_parking_yes * accepts_apple_pay * breweriesToPpl, data = yelp)
v <- summary(m2)$coefficients[,4]
n <- row.names(data.frame(summary(m2)$coefficients[,4]))
d <- data.frame(Variable = n, pValue = v, row.names = 1:(length(v)))
d[d$pValue < .05,]
yelp %>%
filter(price_range != 'expensive') %>%
group_by(price_range) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = price_range, y = ratings)) + geom_bar(stat='identity', width = .6) + geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), width = .5) + ylim(0,5) + theme_bw() +
ylab('Average Rating') + xlab('Price Range')
q()
#library(Hmisc)
library(tidyverse)
library(data.table)
yelp <- read.csv('../data/cleanYelp.csv')
yelp
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme_bw() +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
## convert relevant variables to numeric for correlations
relColumns <- yelp %>%
select(contains('totalhours'), contains('time'), price_range_moderate:accepts_apple_pay_yes, my_ratings, reviews, breweriesToPpl) %>%
colnames()
relColumns
yelp[, relColumns] <- sapply(yelp[,relColumns], as.numeric)
m1 <- rcorr(as.matrix(yelp[,relColumns]))
m1 <- Hmisc::rcorr(as.matrix(yelp[,relColumns]))
#library(Hmisc)
library(tidyverse)
library(data.table)
yelp <- read.csv('../data/cleanYelp.csv')
yelp
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme_bw() +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
## convert relevant variables to numeric for correlations
relColumns <- yelp %>%
select(contains('totalhours'), contains('time'), price_range_moderate:accepts_apple_pay_yes, my_ratings, reviews, breweriesToPpl) %>%
colnames()
relColumns
yelp[, relColumns] <- sapply(yelp[,relColumns], as.numeric)
m1 <- Hmisc::rcorr(as.matrix(yelp[,relColumns]))
## save out only correlations related to ratings
rs <- as.data.frame(m1$r)['my_ratings',]
ps <- as.data.frame(m1$P)['my_ratings',]
## keep significant correlations
critical_ps <- ps %>%
select(-my_ratings) %>%
gather(variable, p_value) %>%
filter(p_value < .05)
rs <- rs %>%
select(-my_ratings) %>%
gather(variable, r_value)
critical_rs <- rs[rs$variable %in% critical_ps$variable,]
critical_rs
m2 <- lm(my_ratings ~ price_range_moderate * caters_yes * parking_street * take_out_yes * accepts_credit_cards * bike_parking_yes * accepts_apple_pay * breweriesToPpl, data = yelp)
v <- summary(m2)$coefficients[,4]
n <- row.names(data.frame(summary(m2)$coefficients[,4]))
d <- data.frame(Variable = n, pValue = v, row.names = 1:(length(v)))
d[d$pValue < .05,]
yelp %>%
filter(price_range != 'expensive') %>%
group_by(price_range) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = price_range, y = ratings)) + geom_bar(stat='identity', width = .6) + geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), width = .5) + ylim(0,5) + theme_bw() +
ylab('Average Rating') + xlab('Price Range')
options(warn = -1)
yelp %>%
filter(price_range != 'expensive') %>%
group_by(price_range, accepts_credit_cards) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings, na.rm = TRUE) / sqrt(n())) %>%
ggplot(aes(x = price_range, y = ratings, group = factor(accepts_credit_cards))) + geom_bar(stat = 'identity', aes(fill = factor(accepts_credit_cards)), position = position_dodge(width = .9)) +
geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), position = position_dodge(width = .9), width = .5) + ylim(0,5) + theme_bw() +
xlab('Price Range') + ylab('Average Rating') +
theme(legend.position = 'top', axis.title.x = element_text(margin = margin(t = 10))) +
guides(fill = guide_legend(title='Does the brewery accept credit cards?')) + scale_fill_manual(values = c('black', 'light grey'))
## Group breweries per capita
yelp <- yelp %>%
group_by(state) %>%
summarize(breweriesToPpl = max(breweriesToPpl)) %>%
arrange(breweriesToPpl) %>%
mutate(rank = 1:(nrow(.))) %>%
mutate(breweriesToPplFactor = factor(ifelse(rank < 50/3, 'Low', ifelse(rank > 100/3, 'High', 'Medium')))) %>%
select(state, breweriesToPplFactor) %>%
inner_join(yelp, by = 'state')
yelp %>%
group_by(take_out) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = take_out, y = ratings)) + geom_bar(stat='identity', width = .6) + geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), width = .5) + ylim(0,5) + theme_bw() +
xlab('Does the brewery have take out?') + ylab('Average Rating')
yelp %>%
group_by(take_out, bike_parking) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = take_out, y = ratings, fill = bike_parking)) + geom_bar(stat='identity', aes(fill = bike_parking), position = position_dodge(width = .9)) +
geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), width = .5, position = position_dodge(width = .9)) + ylim(0,5) + theme_bw() +
xlab('Does the brewery have take out?') + ylab('Average Rating') +
scale_fill_manual(values = c('black', 'light grey'), name = 'Bike Parking Available') +
theme(legend.position = 'top')
yelp %>%
group_by(state) %>%
summarize(breweriesToPpl = max(breweriesToPpl)) %>%
ggplot(aes(x = reorder(state, breweriesToPpl, sum), y = breweriesToPpl, group = 1)) + geom_line() + coord_flip() + xlab('State (increasing in ratio of breweries to people)') +
ylab('Breweries Per Capita') + theme_bw() + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
yelp <- yelp %>%
mutate(breweriesToPplFactor = factor(breweriesToPplFactor, levels = levels(yelp$breweriesToPplFactor)[c(2,3,1)]),
take_out = recode(take_out, 'Yes' = 'Take Out Yes', 'No' = 'Take Out No'))
yelp %>%
group_by(breweriesToPplFactor, bike_parking, take_out) %>%
summarize(rating = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = breweriesToPplFactor, y = rating, group = bike_parking)) +
geom_bar(stat = 'identity', aes(fill = bike_parking), position = position_dodge(width = 0.9)) +
geom_errorbar(aes(ymin = rating - se, ymax = rating + se), position = position_dodge(width = .9), width = .5) +
facet_wrap(~take_out) +
ylim(0,5) +
scale_fill_manual(values = c('black','light grey'), name = 'Bike Parking Available') +
theme_bw() +
xlab('Breweries Per Capita') +
ylab('Yelp Rating') +
theme(legend.position = 'top',
strip.background = element_rect(fill = 'white', color = 'black'))
library(knitr)
library(tidyverse)
library(data.table)
library(chron)
library(imputeMissings)
library(fastDummies)
library(stringr)
#library(Hmisc)
library(tidyverse)
library(data.table)
yelp <- read.csv('../data/cleanYelp.csv')
yelp
yelp %>%
gather(rating_type, rating, ratings, my_ratings) %>%
mutate(rating_type = fct_recode(rating_type, 'Yelp Ratings' = 'ratings', 'My Converted Ratings' = 'my_ratings')) %>%
ggplot(aes(x = rating)) + geom_density(fill = 'blue', alpha = .8) + xlab('Ratings') + facet_wrap(~rating_type) +
theme_bw() +
theme(strip.background = element_rect(fill = 'white', color = 'black'))
## convert relevant variables to numeric for correlations
relColumns <- yelp %>%
select(contains('totalhours'), contains('time'), price_range_moderate:accepts_apple_pay_yes, my_ratings, reviews, breweriesToPpl) %>%
colnames()
relColumns
yelp[, relColumns] <- sapply(yelp[,relColumns], as.numeric)
m1 <- Hmisc::rcorr(as.matrix(yelp[,relColumns]))
## save out only correlations related to ratings
rs <- as.data.frame(m1$r)['my_ratings',]
ps <- as.data.frame(m1$P)['my_ratings',]
## keep significant correlations
critical_ps <- ps %>%
select(-my_ratings) %>%
gather(variable, p_value) %>%
filter(p_value < .05)
rs <- rs %>%
select(-my_ratings) %>%
gather(variable, r_value)
critical_rs <- rs[rs$variable %in% critical_ps$variable,]
critical_rs
m2 <- lm(my_ratings ~ price_range_moderate * caters_yes * parking_street * take_out_yes * accepts_credit_cards * bike_parking_yes * accepts_apple_pay * breweriesToPpl, data = yelp)
v <- summary(m2)$coefficients[,4]
n <- row.names(data.frame(summary(m2)$coefficients[,4]))
d <- data.frame(Variable = n, pValue = v, row.names = 1:(length(v)))
d[d$pValue < .05,]
yelp %>%
filter(price_range != 'expensive') %>%
group_by(price_range) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = price_range, y = ratings)) + geom_bar(stat='identity', width = .6) + geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), width = .5) + ylim(0,5) + theme_bw() +
ylab('Average Rating') + xlab('Price Range')
options(warn = -1)
yelp %>%
filter(price_range != 'expensive') %>%
group_by(price_range, accepts_credit_cards) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings, na.rm = TRUE) / sqrt(n())) %>%
ggplot(aes(x = price_range, y = ratings, group = factor(accepts_credit_cards))) + geom_bar(stat = 'identity', aes(fill = factor(accepts_credit_cards)), position = position_dodge(width = .9)) +
geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), position = position_dodge(width = .9), width = .5) + ylim(0,5) + theme_bw() +
xlab('Price Range') + ylab('Average Rating') +
theme(legend.position = 'top', axis.title.x = element_text(margin = margin(t = 10))) +
guides(fill = guide_legend(title='Does the brewery accept credit cards?')) + scale_fill_manual(values = c('black', 'light grey'))
## Group breweries per capita
yelp <- yelp %>%
group_by(state) %>%
summarize(breweriesToPpl = max(breweriesToPpl)) %>%
arrange(breweriesToPpl) %>%
mutate(rank = 1:(nrow(.))) %>%
mutate(breweriesToPplFactor = factor(ifelse(rank < 50/3, 'Low', ifelse(rank > 100/3, 'High', 'Medium')))) %>%
select(state, breweriesToPplFactor) %>%
inner_join(yelp, by = 'state')
yelp %>%
group_by(take_out) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = take_out, y = ratings)) + geom_bar(stat='identity', width = .6) + geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), width = .5) + ylim(0,5) + theme_bw() +
xlab('Does the brewery have take out?') + ylab('Average Rating')
yelp %>%
group_by(take_out, bike_parking) %>%
summarize(ratings = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = take_out, y = ratings, fill = bike_parking)) + geom_bar(stat='identity', aes(fill = bike_parking), position = position_dodge(width = .9)) +
geom_errorbar(aes(ymin = ratings - se, ymax = ratings + se), width = .5, position = position_dodge(width = .9)) + ylim(0,5) + theme_bw() +
xlab('Does the brewery have take out?') + ylab('Average Rating') +
scale_fill_manual(values = c('black', 'light grey'), name = 'Bike Parking Available') +
theme(legend.position = 'top')
yelp %>%
group_by(state) %>%
summarize(breweriesToPpl = max(breweriesToPpl)) %>%
ggplot(aes(x = reorder(state, breweriesToPpl, sum), y = breweriesToPpl, group = 1)) + geom_line() + coord_flip() + xlab('State (increasing in ratio of breweries to people)') +
ylab('Breweries Per Capita') + theme_bw() + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())
yelp <- yelp %>%
mutate(breweriesToPplFactor = factor(breweriesToPplFactor, levels = levels(yelp$breweriesToPplFactor)[c(2,3,1)]),
take_out = recode(take_out, 'Yes' = 'Take Out Yes', 'No' = 'Take Out No'))
yelp %>%
group_by(breweriesToPplFactor, bike_parking, take_out) %>%
summarize(rating = mean(my_ratings), se = sd(my_ratings) / sqrt(n())) %>%
ggplot(aes(x = breweriesToPplFactor, y = rating, group = bike_parking)) +
geom_bar(stat = 'identity', aes(fill = bike_parking), position = position_dodge(width = 0.9)) +
geom_errorbar(aes(ymin = rating - se, ymax = rating + se), position = position_dodge(width = .9), width = .5) +
facet_wrap(~take_out) +
ylim(0,5) +
scale_fill_manual(values = c('black','light grey'), name = 'Bike Parking Available') +
theme_bw() +
xlab('Breweries Per Capita') +
ylab('Yelp Rating') +
theme(legend.position = 'top',
strip.background = element_rect(fill = 'white', color = 'black'))
q()
